<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section data-transition="slide">


						<img src="polymer_logo.png" style="background:none; border:none; box-shadow:none;">


				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						At Google I/O 2013, Google presented a new web user interface (UI) framework called Polymer.

						The way it works is indicative of the future of all web UI frameworks.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						# Polymer.js

						- Polymer is a library for creating Web Components, which are a set of W3C standards and upcoming browser APIs for defining your own custom HTML elements.

						- The Polymer library provides a set of features for creating custom elements.

						- These features are designed to make it easier and faster to make custom elements that work like standard DOM elements.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Built for Speed
						Polymer 1.0 replaces the shadow DOM <a href="#/polyfill">polyfill</a> with a lightweight shim, uses a new, faster data-binding system, and significantly reduces code size.

						## For Modern Browsers
						 - Polymer is built from the ground up for modern browsers, using the latest web platform APIs.
						 - Polyfills provide support on evergreen browsers for APIs that aren't universal yet.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## On Polyfills
						- Term coined by Remy Sharp

						- As defined by Sharp, "A polyfill, or polyfiller, is a piece of code (or plugin) that provides the technology that you, the developer, expect the browser to provide natively. Flattening the API landscape, if you will."

						- Sharp decided upon the term polyfill that can imply filling in missing browser functionality and using any number of techniques (poly means “many” in Greek).

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- Polyfills allow fixing issues with a browser's API or adding interfaces that haven't been implemented at all.

						- A polyfill is a shim for a browser API. Typically, a developer will programmatically check if a browser supports an API and will load a polyfill if the API is absent.
						 - This allows development to proceed as if the API was native to the browser.

						- Polyfill differs from a shim, in that it can be removed without any changes to the rest of the code once the un-implemented API it substitutes for is properly included in the browser.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						<b>Trivia</b> : Polyfilla, a paste used to cover up cracks & holes in walls, was also a visualization that Sharp found fitting for the term.

					</script>
				</section>


				<section id="polyfill" data-markdown data-transition="slide">
					<script type="text/template">
						## Web Components

						- Polymer leverages web components, a new set of standards designed to provide reusable components for the web.

						- Web Components are a collection of standards which are working their way through the W3C and landing in browsers as we speak.

						- In a nutshell, they allow us to bundle markup and styles into custom HTML elements.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- What's truly amazing about these new elements is that they fully encapsulate all of their HTML and CSS.
							- That means the styles that you write always render as you intended, and your HTML is safe from the prying eyes of external JavaScript.

						- Native Web Components are best supported by the Chrome web browser.
							- Chrome version 36 was the first browser to ship all of the new standards.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Overview of Features

						- The Polymer library provides a set of features for creating custom elements.
						- These features are designed to make it easier and faster to make custom elements that work like standard DOM elements.
						- Similar to standard DOM elements, Polymer elements can be:

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- What this library can do, is allow us to create reusable components that work as true DOM elements while helping to minimize our reliance on JavaScript to do complex DOM manipulation to render rich UI results.

						- An example from the polymer site is rendering a working clock on a web page

						- The syntax looks like this
						```
						<polymer-ui-clock></polymer-ui-clock>
						```

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- The result looks like this :

						<img src="clock.png" style="background:none; border:none; box-shadow:none;">

						- Making the above happen using vanilla Javascript would require some heavy duty JS code, but as we can see, just one line of code can accomplish it using Polymer

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- ## Features of Polymer
							- Registering a Custom Element
							- Lifecycle
							- Properties
							- Local Document Object Model
							- Data Binding
							- Events
							- Behaviour

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Register Custom Elements
						- Polymer gives us the ability to create our own custom elements from scratch and even reuse other elements to extend our custom ones.

						- A template of the new element is first created.

						- This template is a combination of HTML, CSS, JS and includes the functionality that will be available when you use the element.

						- It's based off the WhatWG HTML Templates specification which is meant to provide native support for client-side templating.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- From the polymer.js documentation we can take the following example :
							- register an element
							```
							MyElement = Polymer(
							{
  							is: 'my-element',
								created: function()
								{
									this.textContent = 'My element!';
								}
							});
							```

							- create an instance with createElement:
							```
							var el1 = document.createElement('my-element');
							```
							- ... or with the constructor:
							```
							var el2 = new MyElement();
							```

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- The Polymer function registers the element with the browser and returns a basic Base constructor that can be used to create new instances of your element via code.

						- If arguments are to be passed to the constructor to configure the new element, you can specify a custom <b>factoryImpl</b> function on the prototype.

						```
						MyElement = Polymer(
						{
  						is: 'my-element',
  						factoryImpl: function(foo, bar)
							{
								this.foo = foo;
								this.configureWithBar(bar);
							}, ...
						});
						```
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- Custom elements can also be registered using <b>document.registerElement():</b>

						```
						var XFoo = document.registerElement('x-foo');
						document.body.appendChild(new XFoo());
						```

						- The first argument to document.registerElement() is the element's tag name. The name must contain a dash (-).

						- By default, custom elements inherit from HTMLElement. Thus, the previous example is equivalent to:

						```
						var XFoo = document.registerElement('x-foo',
						{
							prototype: Object.create(HTMLElement.prototype)
						}
						);
						```
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Extending Elements
						- Custom elements allows you to extend existing (native) HTML elements as well as other custom elements.

						- To extend an element, you need to pass registerElement() the name and prototype of the element to inherit from.

							- To create an <x-foo-extended> element that extends the <x-foo> custom element, simply inherit its prototype and say what tag you're inheriting from:

						```
						var XFooProto = Object.create(HTMLElement.prototype);
						...
						var XFooExtended = document.registerElement('x-foo-extended',
						{
							prototype: XFooProto,
							extends: 'x-foo'
						});
						```
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Lifecycle Callbacks

						- Lifecycle callbacks are functions that are automatically called before or after certain actions developed on models.

						- For example, we sometimes use lifecycle callbacks to automatically encrypting a password before creating or updating an `Account` model.

						- Polymer’s Base prototype implements the standard Custom Element lifecycle callbacks to perform tasks necessary for Polymer’s built-in features.

						- The hooks in turn call shorter-named lifecycle methods on your prototype.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- Some of the short-named lifecycle callbacks are :
							- `created` instead of `createdCallback`
							- `attached` instead of `attachedCallback`
							- `detached` instead of `detachedCallback`
							- `attributeChanged` instead of `attributeChangedCallback`

						- We can fallback to using the low-level methods instead of the short-named ones
							- i.e., vanilla createdCallback functions can be implemented in your prototype

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- When Polymer finishes initializing the element's local Document Object Model, Polymer adds an extra callback called `ready`.

						- Local DOM initialization and the `ready` callback occur one after the other.

						- The ready callback is called when an element’s local DOM is ready.

						-	It is called after the element’s template has been stamped and all elements inside the element’s local DOM have been configured and their ready method has been called.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- The initialization order of an element is as follows :
							- created callback
							- local DOM initialized
							- ready callback
							- factoryImpl callback
							- attached callback

						- For a given element:
							- The created callback is always called before ready.
							- The ready callback is always called before attached.
							- The ready callback is called on any local DOM children before it’s called on the host element.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- Implement ready when it’s necessary to manipulate an element’s local DOM when the element is constructed.

						```
						ready: function()
						{
  						// access a local DOM element by ID using this.$
  						this.$.header.textContent = 'Hello!';
						}
						```

						- Within a given tree, ready is generally called in document order, but you should not rely on the ordering of initialization callbacks between sibling elements, or between a host element and its light DOM children.
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- the initialization order may vary depending on whether or not the browser includes native support for web components.

						- In particular, there are no guarantees with regard to initialization timing between sibling elements or between parents and light DOM children.

						- an element’s light DOM children may be initialized before or after the parent element, and an element’s siblings may become ready in any order.
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Some Basics about the Local DOM

						- the DOM that an element is in charge of creating and managing is called its local DOM

						- On browsers that support shadow DOM, shadow DOM may be used to create local DOM.
							- On other supported browsers, Polymer provides local DOM via a custom implementation called shady DOM which requires you to use the Polymer DOM API when manipulating DOM from JavaScript.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- Shadow DOM refers to the ability of the browser to include a subtree of DOM elements into the rendering of a document, but not into the main document DOM tree. Consider a simple slider:

						```
						<input id="foo" type="range">
 						```
						- Any Webkit-enabled broswer should render the following code as

						<center><input id="foo" type="range"></center>

						- Try sliding the slider along the given range

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- There’s a separate movable element inside of the input element, but it isn't visible using JS

						- Browser developers realized that coding the appearance and behavior of HTML elements completely by hand is hard and silly.

						- They created a boundary between what web developer can reach and what’s considered implementation details, thus inaccessible to the user.
							- The browser however, can traipse across this boundary at will.

						- With this boundary in place, they were able to build all HTML elements using the same good-old Web technologies, out of the divs and spans.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Styling

						- Polymer uses Shadow DOM styling rules for providing scoped styling of the element’s local DOM.

						- Scoped styles should be provided via `style` tags placed inside the element’s local DOM `template`
							- Prior to Polymer 1.1, the recommendation was to place `style` tags inside the `dom-module` for an element (but outside the `template`).
							-  Still supported, but no longer recommended

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">


					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Special Features

						- Web Components and Polymer have a lot of features that sometimes the smaller yet intriguing features are overlooked.

						- A few such nice features of Polymer are :
							- Built-in Element Methods
							- Layout Attributes
							- Auto-Binding Templates
							- Attribute Reflection

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Built-In Element Methods

						- Besides using `fire()` to trigger custom events from within a Polymer element, there's another convenient method to do that.

						- `async(fn, inArgs, inTimeout)` allows you to delay the execution of code (similar to setTimeout or requestAnimationFrame) while keeping this bound appropriately.

						- It comes in handy for things like allowing an event to fully propagate before performing a dependent action.

						```
						// executes at the next micro-task checkpoint
						this.async(function()
						{
							this.$.request.go();
						})
						```
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- job(jobName, fn, inTimeout) gives the ability to limit how frequently an action is performed.

						- Jobs are only executed after inTimeout milliseconds have passed without the same job being called again.

						- This pattern is popularly known as debounce.
							- It's great for handling things like listening for noisy event streams like keystrokes or mouse movements.


						```
						// executes when it hasn't been called for 750ms
						this.job('keyup', function()
						{
							this.fire('save');
						}, 750);
					  ```

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Layout Attributes

						- The Polymer documentation is sprinkled with words such as layout, center, or flex across it.

						- Polymer ships with declarative attributes that let you quickly and easily create complex layouts using CSS Flexbox.

						- The Flexbox Layout (Flexible Box) module (currently a W3C Last Call Working Draft) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word "flex").

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						- The main idea behind the flex layout is to give the container the ability to alter its items' width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes).

						- A flex container expands items to fill available free space, or shrinks them to prevent overflow.

						```html
						<body fullbleed layout vertical>
							<header>This will be at the top</header>
							<main flex>This will fill available space</main>
							<footer>This will be at the bottom</footer>
						</body>
						```

						- The above code will enable us to create mobile-friendly layout with header, footer and content.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Auto-Binding Templates

						- Polymer's template binding requires the use of ```auto-binding``` to be used outside the Shadow DOM.

						- The auto-binding template is an extension of the ```<template>``` tag that automatically binds the element itself as the model.


							```html
							<template id="greeter" is="auto-binding" repeat="{{name in names}}">
								<p>Hello, {{name}}, how are you today?</p>
							</template>
							...

							```
						- Auto-binding templates can exist anywhere on the page and don't depend on a user-defined custom element.
					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						## Attribute Reflection

						- Polymer makes it easy for attributes defined in the source code to configure properties on the DOM node
							- This also translates both ways

						- By using a special form of published in your element definition, you can make it so that the attribute values change to match changing properties.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						```
							<polymer-element name="two-way">
								<script>
								Polymer('two-way', {
									published: {
										name: {
											value: 'Bob',
											reflect: true
										}
									}
								});

								`<script>`
							</polymer-element>

						````

						- If the above element were to be used in a webpage and the `name` property changed in JavaScript, the name attribute in the web inspector would change, too.

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						<center>All credits to Reveal.js for presentation animation and layout</center>
						https://github.com/hakimel/reveal.js/

					</script>
				</section>

				<section data-markdown data-transition="slide">
					<script type="text/template">
						Content pulled / referenced from :
						1. https://www.polymer-project.org/1.0/
						2. https://remysharp.com/2010/10/08/what-is-a-polyfill
						3. https://css-tricks.com/modular-future-web-components/
						4. http://code.tutsplus.com/tutorials/using-polymer-to-create-web-components--cms-20475
						5. http://www.html5rocks.com/en/tutorials/webcomponents/customelements/
						6. http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/
						7. https://css-tricks.com/snippets/css/a-guide-to-flexbox/


					</script>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/slide/concave/slide

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/slide-js/slide.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
